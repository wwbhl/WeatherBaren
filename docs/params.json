{"name":"WeatherBar","tagline":"Demo weather app for Etsy School class on writing a Mac app in Swift","body":"# Write a Mac Menu Bar App in Swift\r\n\r\nThis tutorial will walk you through writing a Mac Menu Bar (aka Status Bar) app, using Swift.\r\n\r\n### Create the Project\r\n- Open Xcode\r\n- Create a New Project or File -> New -> Project\r\n- Choose Application -> Cocoa Application under OS X and click Next\r\n- Product Name: WeatherBar, Language Swift, uncheck Use Storyboards\r\n- Next and save somewhere\r\n\r\n### Let's Code!\r\n\r\n- Click on MainMenu.xib\r\n- Under Objects, delete the default window and menu\r\n- Go to the library, type \"menu\" and drag out an NSMenu\r\n- Delete all but one item\r\n- rename item to Quit. In Attributes Inspector (⌥⌘4), click on the Key Equivalent field and type ⌘Q\r\n- Open the Assistant Editor (⌥⌘↩)\r\n- ctrl-drag from Menu to code (AppDelegate.swift) and create a statusMenu outlet\r\n- ctrl-drag from the Quit menu item to the code and create a quitClicked action (set type to NSMenuItem)\r\n- in AppDelegate.swift:\r\n    - delete the `window` var\r\n    - under `statusMenu`, add:\r\n\r\n```swift\r\nlet statusItem = NSStatusBar.systemStatusBar().statusItemWithLength(-1) // NSVariableStatusItemLength\r\n```\r\n\r\n(The `NSVariableStatusItemLength` (-1) and `NSSquareStatusItemLength` (-2) constants have not been ported over to Swift yet.)\r\n    - in `applicationDidFinishLaunching`, add:\r\n\r\n```swift\r\nstatusItem.title = \"WeatherBar\"\r\nstatusItem.menu = statusMenu\r\n```\r\n\r\n- in `quitClicked`:\r\n\r\n    NSApplication.sharedApplication().terminate(self)\r\n\r\n- run it\r\n\r\n## Get rid of the dock icon and menu\r\n\r\n- click target, then info\r\n- in properties, add new property (click on the last property and then on the + that appears)\r\n- type \"Application is agent (UIElement)\" and set the value to YES\r\n- run again\r\n\r\n## Create an icon\r\n\r\n- Create the icon\r\n    + have two icons, one 18x18 and one 36x36\r\n    + click Images.xcassets, then plus on the bottom of the next panel to the right, and select new image set\r\n    + name the image set \"statusIcon\" and drag the icons into the 1x and 2x boxes\r\n\r\n\r\n- in `applicationDidFinishLaunching`:\r\n\r\n    let icon = NSImage(named: \"statusIcon\")\r\n    icon?.setTemplate(true) // best for dark mode\r\n    statusItem.image = icon\r\n    statusItem.menu = statusMenu\r\n\r\n- delete the statusItem.title line\r\n\r\n- run again\r\n\r\n## Reorganize\r\n\r\nBefore we add more code, we should find a better place to put it. The ApplicationDelegate is really meant to be used only for handling application lifecycle events. We *could* dump all our code in there, but at some point you're going to hate yourself (or the next developer to work on your code will be thinking stabby thoughts).\r\n\r\n- File -> New File -> Source -> Swift File -> \"StatusMenuController\"\r\n\r\n    import Foundation\r\n    import Cocoa\r\n\r\n    class StatusMenuController: NSObject {\r\n        @IBOutlet weak var statusMenu: NSMenu!\r\n\r\n        let statusItem = NSStatusBar.systemStatusBar().statusItemWithLength(-1) // NSVariableStatusItemLength\r\n\r\n        override func awakeFromNib() {\r\n            let icon = NSImage(named: \"statusIcon\")\r\n            icon?.setTemplate(true) // best for dark mode\r\n            statusItem.image = icon\r\n            statusItem.menu = statusMenu\r\n        }\r\n\r\n        @IBAction func quitClicked(sender: NSMenuItem) {\r\n            NSApplication.sharedApplication().terminate(self)\r\n        }\r\n    }\r\n\r\n- Go to MainMenu.xib\r\n- In the Library, type \"object\", and then drag an Object over to just above your Menu.\r\n- Name the Object \"StatusMenuController\", select the Identity Inspector (⌥⌘3), and enter \"StatusMenuController\" in the Class field\r\n- right-click on the StatusMenuController object, and under Outlets, drag the circle next to statusMenu over to your Menu object.\r\n- do that again for the quit-clicked action, going to your Quit menu item\r\n- finally, right-click on the App Delegate object and click the X next to the statusMenu outlet to clear that association.\r\n- Now, when the application is launched and the StatusMenu.xib is instantiated, our StatusMenuController will receive `awakeFromNib`, and we can do what we need to initialize the status menu.\r\n- Delete the code we added to AppDelegate\r\n\r\n## Calling the API\r\n\r\nThe next thing we need is something to manage communication with the weather API\r\n\r\n- File -> New File -> Source -> Swift File -> WeatherAPI.swift\r\n\r\n```swift\r\nclass WeatherAPI {\r\n    let BASE_URL = \"http://api.openweathermap.org/data/2.5/weather?units=imperial&q=\"\r\n\r\n    func fetchWeather(query: String) {\r\n        let session = NSURLSession.sharedSession()\r\n        let escapedQuery = query.stringByAddingPercentEncodingWithAllowedCharacters(NSCharacterSet.URLQueryAllowedCharacterSet())\r\n        let url = NSURL(string: BASE_URL + escapedQuery!)\r\n        let task = session.dataTaskWithURL(url!) { data, response, error in\r\n            let dataString = NSString(data: data, encoding: NSUTF8StringEncoding) as String\r\n            NSLog(dataString)\r\n        }\r\n        task.resume()\r\n    }\r\n}\r\n```\r\n\r\nNow we need a way to call this. We could just stick a call in AppDelegate or StatusMenuController#awakeFromNib, but lets be a little less lazy and add a menu item to call it.\r\n\r\n- in MainMenu.xib, type \"Menu Item\" into the library search field (bottom right), and drag a menuItem over to above Quit in your menu\r\n- while we're at it, drag a Separator Menu Item between those two\r\n- Rename the new menu item \"Update\" (and give it a key equivalent if you want)\r\n- Open the Assistant Editor with StatusMenuController.swift and ctrl-drag from Update over to your code above `quitClicked` and create a new action, `updateClicked`, with the type again as `NSMenuItem`\r\n- we need to instantiate WeatherAPI, so in StatusMenuController at the top, under `let statusItem` add:\r\n\r\n```swift\r\nlet weatherAPI = WeatherAPI()\r\n```\r\n\r\nand in `updateClicked`, add:\r\n\r\n```swift\r\nweatherAPI.fetchWeather(\"Seattle\")\r\n```\r\n\r\n- run it, and select Update\r\n\r\n- you probably want it to fetch the weather as soon as the app launches. I reorganized my `StatusMenuController` a bit to do this. Here's what it looks like now:\r\n\r\n```swift\r\nclass StatusMenuController: NSObject {\r\n    @IBOutlet weak var statusMenu: NSMenu!\r\n\r\n    let statusItem = NSStatusBar.systemStatusBar().statusItemWithLength(-1) // NSVariableStatusItemLength\r\n    let weatherAPI = WeatherAPI()\r\n\r\n    override func awakeFromNib() {\r\n        let icon = NSImage(named: \"statusIcon\")\r\n        icon?.setTemplate(true) // best for dark mode\r\n        statusItem.image = icon\r\n        statusItem.menu = statusMenu\r\n\r\n        updateWeather()\r\n    }\r\n\r\n    func updateWeather() {\r\n        weatherAPI.fetchWeather(\"Seattle\")\r\n    }\r\n\r\n    @IBAction func updateClicked(sender: NSMenuItem) {\r\n        updateWeather()\r\n    }\r\n\r\n    @IBAction func quitClicked(sender: NSMenuItem) {\r\n        NSApplication.sharedApplication().terminate(self)\r\n    }\r\n}\r\n```\r\n\r\n## Parsing JSON\r\n\r\nParsing JSON is a little awkward in Swift, and people have written libraries, like [SwiftyJSON](https://github.com/SwiftyJSON/SwiftyJSON) to make this easier, but our needs our simple and I don't want to complicate things with installing external libraries (although if you do, the two main package managers for Xcode are [Carthage](https://github.com/Carthage/Carthage) and CocoaPODS(http://cocoapods.org/)).\r\n\r\nHere's the JSON returned by OpenWeatherMap:\r\n\r\n```json\r\n{\r\n    \"coord\": {\r\n        \"lon\": -122.33,\r\n        \"lat\": 47.6\r\n    },\r\n    \"sys\": {\r\n        \"type\": 1,\r\n        \"id\": 2923,\r\n        \"message\": 0.0242,\r\n        \"country\": \"United States of America\",\r\n        \"sunrise\": 1426774374,\r\n        \"sunset\": 1426818056\r\n    },\r\n    \"weather\": [{\r\n        \"id\": 800,\r\n        \"main\": \"Clear\",\r\n        \"description\": \"sky is clear\",\r\n        \"icon\": \"01d\"\r\n    }],\r\n    \"base\": \"cmc stations\",\r\n    \"main\": {\r\n        \"temp\": 52.41,\r\n        \"pressure\": 1020,\r\n        \"humidity\": 76,\r\n        \"temp_min\": 48.2,\r\n        \"temp_max\": 57\r\n    },\r\n    \"wind\": {\r\n        \"speed\": 7.78,\r\n        \"deg\": 180\r\n    },\r\n    \"clouds\": {\r\n        \"all\": 1\r\n    },\r\n    \"dt\": 1426790612,\r\n    \"id\": 5809844,\r\n    \"name\": \"Seattle\",\r\n    \"cod\": 200\r\n}\r\n```\r\n\r\nThere's a lot of information we could use here, but for now let's just take the city name, current temperature, and the weather description. Let's first create a place to put the weather data. In WeatherAPI.swift, add a struct at the top of the file:\r\n\r\n```swift\r\nstruct Weather {\r\n    var city: String\r\n    var currentTemp: Float\r\n    var conditions: String\r\n}\r\n```\r\n\r\nNow add a function to parse the incoming JSON data and return a Weather object:\r\n\r\n```swift\r\nfunc weatherFromJSONData(data: NSData) -> Weather? {\r\n    var err: NSError?\r\n    typealias JSONDict = [String:AnyObject]\r\n\r\n    if let json = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.allZeros, error: &err) as? JSONDict {\r\n        var mainDict = json[\"main\"] as JSONDict\r\n        var weatherList = json[\"weather\"] as [JSONDict]\r\n        var weatherDict = weatherList[0]\r\n\r\n        var weather = Weather(\r\n            city: json[\"name\"] as String,\r\n            currentTemp: mainDict[\"temp\"] as Float,\r\n            conditions: weatherDict[\"main\"] as String\r\n        )\r\n\r\n        return weather\r\n    }\r\n    return nil\r\n}\r\n```\r\n\r\nWe return an Optional(Weather) because it's possible the JSON may fail to parse.\r\n\r\nNow, change the `fetchWeather` function to call `weatherFromJSONData`:\r\n\r\n```swift\r\nlet task = session.dataTaskWithURL(url!) { data, response, error in\r\n    let weather = self.weatherFromJSONData(data)\r\n    NSLog(\"\\(weather)\")\r\n}\r\n```\r\n\r\nIf you run it now, you'll see that the logging isn't terribly helpful:\r\n\r\n```\r\n2015-03-19 14:58:00.758 WeatherBar[49688:1998824] Optional(WeatherBar.Weather)\r\n```\r\n\r\nTo make our Weather struct printable, we need to implement the [Printable](https://developer.apple.com/library/ios/documentation/General/Reference/SwiftStandardLibraryReference/Printable.html) or DebugPrintable protocols. Let's do the former:\r\n\r\n```swift\r\nstruct Weather: Printable {\r\n    var city: String\r\n    var currentTemp: Float\r\n    var conditions: String\r\n\r\n    var description: String {\r\n        return \"\\(city): \\(currentTemp)F and \\(conditions)\"\r\n    }\r\n}\r\n```\r\n\r\nIf you run it again now you'll see:\r\n\r\n```\r\n2015-03-19 15:11:49.130 WeatherBar[50731:2009152] Optional(Seattle: 58.87F and Clouds)\r\n```\r\n\r\n## Getting the Weather into the Controller\r\n\r\nNext, let's actually display the weather in our app, as opposed to in the debug console.\r\n\r\nFirst we have the problem of how we get the weather data back into our controller. The weather API call is asynchronous, so we can't just call weatherAPI.fetchWeather() and expect a Weather object in return.\r\n\r\nThere are two common ways to handle this. The most common pattern in MacOS and iOS programming (at least up until recently), is to use a delegate:\r\n\r\nAdd the following above `class WeatherAPI`:\r\n\r\n```swift\r\nprotocol WeatherAPIDelegate {\r\n    func weatherDidUpdate(weather: Weather)\r\n}\r\n```\r\n\r\nAdd the following class variable to WeatherAPI:\r\n\r\n```swift\r\nvar delegate: WeatherAPIDelegate?\r\n```\r\n\r\nAdd an initializer fuction:\r\n\r\n```swift\r\ninit(delegate: WeatherAPIDelegate) {\r\n    self.delegate = delegate\r\n}\r\n```\r\n\r\nAnd now the data fetch task in `fetchWeather` will look like this:\r\n\r\n```swift\r\nlet task = session.dataTaskWithURL(url!) { data, response, error in\r\n    if let weather = self.weatherFromJSONData(data) {\r\n        self.delegate?.weatherDidUpdate(weather)\r\n    }\r\n}\r\n```\r\n\r\nFinally, we implement the `WeatherAPIDelegate` protocol in the controller, with a few changes noted:\r\n\r\n```swift\r\nclass StatusMenuController: NSObject, WeatherAPIDelegate {\r\n...\r\n  var weatherAPI: WeatherAPI!\r\n\r\n  override func awakeFromNib() {\r\n    ...\r\n    weatherAPI = WeatherAPI(delegate: self)\r\n    updateWeather()\r\n  }\r\n  ...\r\n  func weatherDidUpdate(weather: Weather) {\r\n    NSLog(weather.description)\r\n  }\r\n  ...\r\n```\r\n\r\nHowever, with the relatively recent introduction of blocks to Objective-C, and Swift's first-class functions, a simpler way is to use callbacks:\r\n\r\n```swift\r\nfunc fetchWeather(query:String, success: (Weather) -> Void) {\r\n    let session = NSURLSession.sharedSession()\r\n    let escapedQuery = query.stringByAddingPercentEncodingWithAllowedCharacters(NSCharacterSet.URLQueryAllowedCharacterSet())\r\n    let url = NSURL(string: BASE_URL + escapedQuery!)\r\n    let task = session.dataTaskWithURL(url!) { data, response, error in\r\n        if let weather = self.weatherFromJSONData(data) {\r\n            success(weather)\r\n        }\r\n    }\r\n    task.resume()\r\n}\r\n```\r\n\r\nHere, `success` is a function that takes a Weather object as a parameter and returns `Void` (nothing).\r\n\r\nIn our controller:\r\n\r\n```swift\r\nfunc updateWeather() {\r\n    weatherAPI.fetchWeather(\"Seattle, WA\") { weather in\r\n        NSLog(weather.description)\r\n    }\r\n}\r\n```\r\n\r\n## Displaying the Weather\r\n\r\nFinally, we'll update our menu to display the weather.\r\n\r\nIn MainMenu.xib, add a new MenuItem between Update and Quit (and another separator) and rename it \"Weather\".\r\n\r\n![](assets/weather-menu-item.png)\r\n\r\nIn your controller, in `updateWeather`, replace the `NSLog` with:\r\n\r\n```swift\r\nif let weatherMenuItem = self.statusMenu.itemWithTitle(\"Weather\") {\r\n    weatherMenuItem.title = weather.description\r\n}\r\n```\r\n\r\nRun and voila!\r\n\r\nThe weather is greyed out because we have no action associated with selecting it. We could have it open a web page to a detailed forecast, but instead next we'll make a nicer display.\r\n\r\n## Creating a Weather UIView\r\n\r\nOpen MainMenu.xib.\r\n\r\nDrag a Custom View onto the page.\r\n\r\nDrag a Image View into the upper left corner of the view, and in the Image View's Size Inspector, set the width and height to 50.\r\n\r\nAdd Labels for city and current temperature/conditions (we'll use one label for both temperature and conditions).\r\n\r\nAdjust the view size down to about 265 x 90 (you can set that in the Image View's Size Inspector). It should look roughly like this:\r\n\r\n![](assets/image-view.png)\r\n\r\nNew File -> Source -> Cocoa Class, name it WeatherView and make it a subclass of NSView, and save. The file will contain a stub `drawRect` method which you can delete.\r\n\r\nBack in MainMenu.xib, click on the View, and in the Identity Inspector, set the class to \"WeatherView\". Now use the Assistant editor to bring up the xib and class file side-by-side, and then ctrl-drag from the xib to create outlets for each of the elements in the view. WeatherView.swift should look like:\r\n\r\n```swift\r\nimport Cocoa\r\n\r\nclass WeatherView: NSView {\r\n    @IBOutlet weak var imageView: NSImageView!\r\n    @IBOutlet weak var cityTextField: NSTextField!\r\n    @IBOutlet weak var currentConditionsTextField: NSTextField!\r\n}\r\n```\r\n\r\nNow add a method to WeatherView so we can update it with a Weather object:\r\n\r\n```swift\r\n    func update(weather: Weather) {\r\n        cityTextField.stringValue = weather.city\r\n        currentConditionsTextField.stringValue = \"\\(Int(weather.currentTemp))°F and \\(weather.conditions)\"\r\n    }\r\n```\r\n\r\nNow bring up StatusMenuController in the Assistant editor, and ctrl-drag from the Weather View object over to the top of the StatusMenuController class to create a `weatherView` outlet. While we're there, we're going to add a `weatherMenuItem` class var:\r\n\r\n```swift\r\nclass StatusMenuController: NSObject {\r\n    @IBOutlet weak var statusMenu: NSMenu!\r\n    @IBOutlet weak var weatherView: WeatherView!\r\n    var weatherMenuItem: NSMenuItem!\r\n    ...\r\n```\r\n\r\nIn StatusMenuController's `awakeFromNib` method, right before the call to `updateWeather`, add:\r\n\r\n```swift\r\n// load WeatherView\r\nweatherMenuItem = statusMenu.itemWithTitle(\"Weather\")\r\nweatherMenuItem.view = weatherView\r\n```\r\n\r\nAnd now `updateWeather` is even simpler:\r\n\r\n```swift\r\nfunc updateWeather() {\r\n    weatherAPI.fetchWeather(\"Seattle, WA\") { weather in\r\n        self.weatherView.update(weather)\r\n    }\r\n}\r\n```\r\n\r\nRun it!\r\n\r\n## Adding the Weather Image\r\n\r\nSo, we're obviously missing something in our weather view. Let's update it with the appropriate weather image.\r\n\r\nThe images for the various weather conditions can be found at http://openweathermap.org/weather-conditions, but I've put them in a [zip file](assets/weather-icons.zip) for you. You can just unzip that and drag the whole folder into Images.xcassets.\r\n\r\nWe need to update WeatherAPI to capture the icon code. In the Weather struct, add:\r\n\r\n```swift\r\nvar icon: String\r\n```\r\n\r\nand in `weatherFromJSONData`, add that to the Weather initialization:\r\n\r\n```swift\r\nvar weather = Weather(\r\n    city: json[\"name\"] as String,\r\n    currentTemp: mainDict[\"temp\"] as Float,\r\n    conditions: weatherDict[\"main\"] as String,\r\n    icon: weatherDict[\"icon\"] as String\r\n)\r\n```\r\n\r\nNow in the `update` method of WeatherView, add:\r\n\r\n```swift\r\nimageView.image = NSImage(named: weather.icon)\r\n```\r\n\r\nThat's it! Run it.\r\n\r\n## Preferences\r\n\r\nHaving the city hard-coded in the app is not cool. Let's make a Preferences pane so we can change it.\r\n\r\nOpen up MainMenu.xib and drag another MenuItem onto the menu, above Quit, naming it \"Preferences...\".\r\n\r\nOpen up the Assistant editor again with StatusMenuController, and ctrl-drag from the Preferences menu item over to the code and create a \"preferencesClicked\" action.\r\n\r\nNew -> File -> Source -> Cocoa Class. Call it \"PreferencesWindow\", set the subclass to NSWindowController, and check the box to create a XIB file.\r\n\r\nGive the window a title of Preferences. Add a label for \"City:\", and put a Text Field to the right of it. It should look something like this:\r\n\r\n![](assets/preferences.png)\r\n\r\nBring up the Assistant editor with PreferencesWindow.swift and ctrl-drag from the text field to the code and create an outlet named \"cityTextField\".\r\n\r\nIn PreferencesWindow.swift, add:\r\n\r\n```swift\r\noverride var windowNibName : String! {\r\n    return \"PreferencesWindow\"\r\n}\r\n```\r\n\r\nand at the end of `windowDidLoad()`, add:\r\n\r\n```swift\r\nself.window?.center()\r\n```\r\n\r\nIn StatusMenuController.swift, add a `preferencesWindow` class var:\r\n\r\n```swift\r\nvar preferencesWindow: PreferencesWindow!\r\n```\r\n\r\nand initialize in `awakeFromNib()`, before the call to `updateWeather()`:\r\n\r\n```swift\r\npreferencesWindow = PreferencesWindow()\r\n```\r\n\r\nFinally, in the `preferencesClicked` function, add:\r\n\r\n```swift\r\npreferencesWindow.showWindow(nil)\r\n```\r\n\r\nIf you run now, selecting the Preferences... menu item should bring up the preferences window.\r\n\r\nNow, let's actually save and update the city.\r\n\r\nMake the PreferencesWindow class an `NSWindowDelegate`:\r\n\r\n```swift\r\nclass PreferencesWindow: NSWindowController, NSWindowDelegate {\r\n```\r\n\r\nand add:\r\n\r\n```swift\r\nfunc windowWillClose(notification: NSNotification) {\r\n    NSLog(\"city is: \" + cityTextField.stringValue)\r\n}\r\n```\r\n\r\nIf you run it now, you'll see whatever you typed in the text field displayed when you close the window.\r\n\r\nSaving the value is easy:\r\n\r\n```swift\r\nfunc windowWillClose(notification: NSNotification) {\r\n    let defaults = NSUserDefaults.standardUserDefaults()\r\n    defaults.setValue(cityTextField.stringValue, forKey: \"city\")\r\n}\r\n```\r\n\r\nNow we need to notify the StatusMenuController that the preferences have been updated. For this we'll use the Delegate pattern. This is easy, but requires a number of edits. First, at the top of PreferencesWindow.swift, add a `PreferencesWindowDelegate` protocol:\r\n\r\n```swift\r\nprotocol PreferencesWindowDelegate {\r\n    func preferencesDidUpdate()\r\n}\r\n```\r\n\r\nand add a `delegate` instance variable:\r\n\r\n```swift\r\nvar delegate: PreferencesWindowDelegate?\r\n```\r\n\r\nAt the end of `windowWillClose`, we'll call the delegate:\r\n\r\n```swift\r\ndelegate?.preferencesDidUpdate()\r\n```\r\n\r\nBack in StatusMenuController, make it a `PreferencesWindowDelegate`:\r\n\r\n```swift\r\nclass StatusMenuController: NSObject, PreferencesWindowDelegate {\r\n```\r\n\r\nand add the delegate method:\r\n\r\n```swift\r\nfunc preferencesDidUpdate() {\r\n    updateWeather()\r\n}\r\n```\r\n\r\nAnd in `awakeFromNib`, set the delegate:\r\n\r\n```swift\r\npreferencesWindow = PreferencesWindow()\r\npreferencesWindow.delegate = self\r\n```\r\n\r\nAll that's left is to load the city from defaults. First add this at the top of StatusMenuController, under the imports:\r\n\r\n```swift\r\nlet DEFAULT_CITY = \"Seattle, WA\"\r\n```\r\n\r\n(...or whatever you want the default to be.) Yes, this is a global variable, and there are probably better ways to do this (like storing it in Info.plist), but that can be left as an exercise for the reader.\r\n\r\nLoad the saved city, or default, in `updateWeather`:\r\n\r\n```swift\r\nfunc updateWeather() {\r\n    let defaults = NSUserDefaults.standardUserDefaults()\r\n    let city = defaults.stringForKey(\"city\") ?? DEFAULT_CITY\r\n    weatherAPI.fetchWeather(city) { weather in\r\n        self.weatherView.update(weather)\r\n    }\r\n}\r\n```\r\n\r\nFinally, back in PreferencesWindow.swift, we need to add similar code to load any saved city when we show the preferences. At the end of `windowDidLoad`, add:\r\n\r\n```swift\r\nlet defaults = NSUserDefaults.standardUserDefaults()\r\nlet city = defaults.stringForKey(\"city\") ?? DEFAULT_CITY\r\ncityTextField.stringValue = city\r\n```\r\n\r\nRun it!\r\n\r\n## Next Steps\r\n\r\nThat's the end of this tutorial. Obviously there's a lot more that we can do with this, but I'll leave that up to you. Some ideas:\r\n\r\n- Easy\r\n    + Add other weather info (high/low temp, humidity, sunrise/sunset, etc) to the Weather View\r\n    + Change the status menu icon + title to reflect the current conditions\r\n    + Make it so clicking on the Weather View opens a browser with detailed weather information (easy, if you have a url to go to; hint: `NSWorkspace.sharedWorkspace().openURL(url: NSURL)`)\r\n- More Challenging\r\n    + Add support for multiple cities. This will take some effort, especially if the number of cities is dynamic. I think you'll have to put the Weather View in its own XIB, and load it manually (look at `NSBundle.mainBundle().loadNibNamed(name, owner: owner, options: options)`). The UI in Preferences will need to be updated as well.\r\n- You Know Way More Than Me Now\r\n    + Create a completely custom view when clicking on the app in the status bar. See the [Weather Live](https://itunes.apple.com/us/app/weather-live/id755717884?mt=12) app, for example. I haven't tried this, but I suspect it is easier than you might think (depending on how fancy your view is, of course).\r\n\r\n## Resources\r\n\r\n- [The Swift Programming Language](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/)\r\n    + Apple's documentation, also downloadable as a [free iBook](https://itunes.apple.com/us/book/the-swift-programming-language/id881256329?mt=11)\r\n- [Mac Dev Center](https://developer.apple.com/devcenter/mac/)\r\n    + Mac developer account is free, but you need to pay $99/year if you want to distribute your app in the app store.\r\n- [OS X Human Interface Guidelines](https://developer.apple.com/library/mac/documentation/UserExperience/Conceptual/OSXHIGuidelines/)","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}